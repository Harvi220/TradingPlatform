// This is your Prisma schema file for Trading Platform
// Database: PostgreSQL + TimescaleDB extension
// UPDATED: Snapshots saved every MINUTE (not second)
// Version: 1.1

generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// MAIN TABLES
// ============================================

/// Snapshot table for storing BID/ASK volume data
/// Saved EVERY MINUTE (12 snapshots/minute for 1 symbol)
/// This will be converted to TimescaleDB hypertable
model Snapshot {
  id            String   @id @default(cuid())

  /// Timestamp of the snapshot with timezone (rounded to minute)
  timestamp     DateTime @db.Timestamptz(3)

  /// Trading symbol (e.g., BTCUSDT)
  symbol        String   @db.VarChar(20)

  /// Market type: SPOT or FUTURES
  marketType    MarketType

  /// Depth percentage (1.5, 3, 5, 8, 15, 30)
  depth         Float    @db.Real

  // Volume data in base currency
  bidVolume     Float    @db.Real
  askVolume     Float    @db.Real

  // Volume data in USD
  bidVolumeUsd  Float    @db.Real
  askVolumeUsd  Float    @db.Real

  // Metadata
  createdAt     DateTime @default(now()) @db.Timestamptz(3)

  // Indexes for fast queries
  @@index([timestamp(sort: Desc)])
  @@index([symbol, marketType, depth, timestamp(sort: Desc)])
  @@index([symbol, timestamp(sort: Desc)])

  // Prevent duplicate snapshots
  @@unique([symbol, marketType, depth, timestamp])

  @@map("snapshots")
}

/// Enum for market type
enum MarketType {
  SPOT
  FUTURES

  @@map("market_type")
}

// ============================================
// AGGREGATED TABLES
// ============================================

/// 1-hour aggregated snapshots
/// Since raw data is already per minute, we don't need 1-minute aggregates
model SnapshotAgg1h {
  id            String   @id @default(cuid())

  /// Time bucket start (1 hour intervals)
  bucket        DateTime @db.Timestamptz(3)

  symbol        String   @db.VarChar(20)
  marketType    MarketType
  depth         Float    @db.Real

  // Aggregated metrics
  avgBidVolume  Float    @db.Real
  avgAskVolume  Float    @db.Real
  maxBidVolume  Float    @db.Real
  maxAskVolume  Float    @db.Real
  minBidVolume  Float    @db.Real
  minAskVolume  Float    @db.Real

  avgBidVolumeUsd Float  @db.Real
  avgAskVolumeUsd Float  @db.Real

  /// Number of snapshots in this bucket (usually 60 for 1 hour)
  count         Int      @db.Integer

  @@index([bucket(sort: Desc)])
  @@index([symbol, marketType, depth, bucket(sort: Desc)])
  @@unique([symbol, marketType, depth, bucket])

  @@map("snapshots_agg_1h")
}

/// 1-day aggregated snapshots (optional but recommended)
model SnapshotAgg1d {
  id            String   @id @default(cuid())

  /// Time bucket start (1 day intervals)
  bucket        DateTime @db.Timestamptz(3)

  symbol        String   @db.VarChar(20)
  marketType    MarketType
  depth         Float    @db.Real

  // Aggregated metrics
  avgBidVolume  Float    @db.Real
  avgAskVolume  Float    @db.Real
  maxBidVolume  Float    @db.Real
  maxAskVolume  Float    @db.Real
  minBidVolume  Float    @db.Real
  minAskVolume  Float    @db.Real

  avgBidVolumeUsd Float  @db.Real
  avgAskVolumeUsd Float  @db.Real

  /// Number of snapshots in this bucket (usually 1440 for 1 day)
  count         Int      @db.Integer

  @@index([bucket(sort: Desc)])
  @@index([symbol, marketType, depth, bucket(sort: Desc)])
  @@unique([symbol, marketType, depth, bucket])

  @@map("snapshots_agg_1d")
}

// ============================================
// LOGGING TABLES
// ============================================

/// WebSocket events log
model WebSocketEvent {
  id          String   @id @default(cuid())
  timestamp   DateTime @default(now()) @db.Timestamptz(3)

  symbol      String   @db.VarChar(20)
  marketType  MarketType

  eventType   WebSocketEventType

  /// Error message or event description
  message     String?  @db.Text

  /// Additional metadata in JSON format
  metadata    Json?    @db.JsonB

  @@index([timestamp(sort: Desc)])
  @@index([symbol, marketType, timestamp(sort: Desc)])
  @@index([eventType, timestamp(sort: Desc)])

  @@map("websocket_events")
}

enum WebSocketEventType {
  CONNECTED
  DISCONNECTED
  ERROR
  RECONNECTING
  SNAPSHOT_LOADED
  GAP_DETECTED
  UPDATE_FAILED

  @@map("websocket_event_type")
}

/// System metrics for monitoring
model SystemMetric {
  id          String   @id @default(cuid())
  timestamp   DateTime @default(now()) @db.Timestamptz(3)

  /// Metric name (e.g., 'cpu_usage', 'memory_usage', 'db_connections')
  metricName  String   @db.VarChar(50)

  /// Metric value
  metricValue Float    @db.Real

  /// Additional context
  metadata    Json?    @db.JsonB

  @@index([timestamp(sort: Desc)])
  @@index([metricName, timestamp(sort: Desc)])

  @@map("system_metrics")
}
